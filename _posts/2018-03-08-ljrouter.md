---
title: LJRouter源码分析
comments: true
---

[LianjiaTech/LJRouter](https://github.com/LianjiaTech/LJRouter)是链家开源的一款路由组件，使用方法详见链接。这篇文章是对该路由的实现思路的学习。

### 声明注册信息

每一个支持LJRouter的ViewController必须实现Init方法，即：

````objc
LJRouterInit(@"注释", 页面Key, (类型1)参数名1, (类型2)参数名2, ...) // 没有参数可以不写
````
该方法是一个宏，封装了一系列宏和代码。其中有一块代码构建了静态LJRouterRegister结构体，把注册信息，上面代码中的Key和参数们，写入结构体，并指定其存储在名为__LJRouter的数据块中。

````objc
__used static struct LJRouterRegister name_combined_by_params                                                   
__attribute__ ((used, section ("__DATA,__LJRouter"))) = {...}                              
````

### 加载注册信息
程序运行后，在需要进行路由跳转时，调用`loadAllPageProperty`懒加载注册信息。通过上一步定义的标识`__LJRouter`，取出所有注册信息结构体取出

````objc
uint8_t *data = getsectiondata(header, "__DATA", "__LJRouter",&size);
uint32_t count = (uint32_t)(size / sizeof(struct LJRouterRegister));
for (uint32_t i = 0 ; i < count ; i ++) {
    //...见下文
}
````
构造一个更为友好的`LJInvocationCenterItemRule`的类对象，用保存获取Router对象的所有描述信息。如下可见，有selector、返回类型和参数数组。

````objc
@interface LJInvocationCenterItemRule : NSObject
@property (nonatomic, readonly) SEL selector;
@property (nonatomic, readonly) NSString *returnTypeName;
@property (nonatomic, readonly) NSString *returnTypeEncoding;
@property (nonatomic, readonly) NSArray<LJInvocationCenterItemParam*>* paramas;
//...此处省略一个方法
@end
````

将所有构造的Rule对象，相应的Key和Target一并加入`LJInvocationCenter`。Key是`LJRouterInit`中定义的Router标识。Target对应的ViewController类。LJRouter是一个单例，所以加载后这些健值对就常驻在`LJInvocationCenter`内存中了。

````objc
{
     //对...我就是上文循环中的方法...
     //此处先省略一万步...
     LJInvocationCenterItemRule *rule =
                [[LJInvocationCenterItemRule alloc] initWithSelector:NSSelectorFromString(items[i].selName)
                                                      returnTypeName:items[i].returnTypeName
                                                  returnTypeEncoding:[NSString stringWithUTF8String:items[i].returnTypeEncoding]
                                                              params:params];

      [center addInvocationWithKey:items[i].key.lowercaseString
                            target:NSClassFromString(className)
                              rule:rule];
}
            
````

Rule只代表一种构造方法，一个ViewController可以有多种初始化方式。所以在前面`addInvocationWithKey:target:rule`方法中，会将Key、Target和Rule再进一步封装到名为`LJInvocationCenterItem`的对象中，同样Key的不同rule会被添加到rules数组中，LJRouter会rule参数匹配合适方法初始化。

````objc
@interface LJInvocationCenterItem : NSObject

@property (nonatomic, readonly) NSString *key;
@property (nonatomic, readonly) id target;
@property (nonatomic, readonly) NSArray<LJInvocationCenterItemRule*> *rules;

@end
````


### 安全检查
在Debug环境下，通过宏__LJRouterUseCheck定义了安全检查。即在上一步加载完成后，会调用`checkAllMethodTypeName`方法进行校验。如果发现声明`LJRouterInit`和使用`LJRouterUsePage`时的方法名和参数不能匹配，即刻给予抛出异常。使用者能认识到出错的位置。这也是为什么明明可以用字符串类型的URL来进行Route，源码里还要建议用强制声明的函数来跳转。稍显繁琐，但是安全。对于外部跳转，无论App或者WebView，都无可避免的使用URL。这个时候采用下面的routerKey方法，是一个合理的方案。

````objc
- (BOOL)routerKey:(NSString*)key
             data:(NSDictionary*)data
		   sender:(UIResponder*)sender
        pageBlock:(void(^)(__kindof UIViewController* viewController))pageBlock
    callbackBlock:(void(^)(NSString* key,NSString *value,NSString* data,BOOL complete))callbackBlock
canNotRouterBlock:(void(^)(void))canNotRouterBlock;
````

### 路由跳转
`LJRouterUsePage`其实是用宏声明了一个跳转函数。在程序内部，我们通过跳转函数来进行ViewController之间的切换，这样相比用NSString类型的Key来说更加安全和明确，所需参数也一目了然。

````objc
//宏声明
LJRouterUsePage(webview, (NSString*)url);
//实际生成函数
open_webview_controller_with_url(id sender, NSString *url) {
    //do some thing
}
//调用
open_webview_controller_with_url(self, @"http://example.com");
````

跳转函数里面到底做了什么操作呢？以下是宏与objc参杂的一块简化后的代码。

第一步：调用LJRouterGetClassForKey函数，通过Key（上例为webview）从LJInvocationCenter中，获取target，也就是对应的ViewController的Class。

第二步：使用`LJ_ROUTER_FUNCTION_PARAM_SELNAME`结合参数，拼接出这个类的构造的方法，并构造对应的Selector。从这里可以看出来无论是`LJRouterInit`还是`LJRouterUsePage`它们一定是使用相同的拼接逻辑，这样才能保证最终能够匹配成功，而不是出现空指针异常。拼接逻辑详见宏`LJ_ROUTER_FUNCTION_PARAM_DEFINE`和`LJ_ROUTER_FUNCTION_PARAM_SELNAME`。

第三步：通过runtime的`class_getMethodImplementation`方法获取到ViewController真实的函数指针。可以注意到这个是一个类方法，说明`LJRouterInit`同时定义了两个初始化方法，类方法和实例方法，应用于不同的场景。

第四步：调用函数指针，获取ViewController的实例。三四两步都用到了名为`LJ_ROUTER_FOREACH_ARGS`的宏用于展开参数。有兴趣的小伙伴可以进一步研究，宏无能的就先溜了。最后调用openViewController进行跳转。

````objc
//第一步
Class theClass = LJRouterGetClassForKey(@#KEY);

//第二步
NSString *selName =LJ_ROUTER_FUNCTION_PARAM_SELNAME(GET_FUN_PRE,GET_FUN_PRE2,LJ_ROUTER_CREATE_SEL_STR,##__VA_ARGS__);    
SEL sel = NSSelectorFromString(selName);
//第三步

GET_FUN_RET_TYPE(*imp)(id,SEL LJ_ROUTER_FOREACH_ARGS(LJ_ROUTER_PARAMS_DOT_TYPEOF_VALUE,1,##__VA_ARGS__  )) =  (void*)class_getMethodImplementation(object_getClass(theClass), sel);  

//第四步
UIViewController *vc = imp(theClass,sel LJ_ROUTER_FOREACH_ARGS(LJ_ROUTER_PARAMS_DOT_AND_VALUE,1,##__VA_ARGS__)); 
[[LJRouter sharedInstance] openViewController:vc withSender:controller];

````


### 总结
本文只是简单介绍了一下LJRouter从声明到调用的流程。代码中有很多复杂的宏定义，使得在声明的时候变得简洁。但限于本人理解不深，恕不能深入展开。

LJRouter相比市面早期的Router更加高效和安全，以下是我总结的优点：
1. app内用宏定义的函数跳转，目标及传参明确
2. 注册过程全自动化
3. 检查工作能够及早发现定义错误的跳转函数
4. 默认支持字符串类型的类型的路由跳转
5. 自定义错误处理
6. 不仅仅跳转，还可以自定义Action：通过Router调用一个方法
7. 可以导入元数据进行二次开发（详见源码README）

如有错误或疑问，还望不吝致评。

